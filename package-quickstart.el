;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/yaml-mode-20220903.1821/yaml-mode-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/yaml-mode-20220903.1821/yaml-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/yaml-mode-20220903.1821/yaml-mode-autoloads.el") (car load-path))))



(let ((loads (get 'yaml 'custom-loads))) (if (member '"yaml-mode" loads) nil (put 'yaml 'custom-loads (cons '"yaml-mode" loads))))

(autoload 'yaml-mode "yaml-mode" "\
Simple mode to edit YAML.

\\{yaml-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))

(add-to-list 'magic-mode-alist '("^%YAML\\s-+[0-9]+\\.[0-9]+\\(\\s-+#\\|\\s-*$\\)" . yaml-mode))

(register-definition-prefixes "yaml-mode" '("yaml-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/xref-1.5.1/xref-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/xref-1.5.1/xref-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/xref-1.5.1/xref-autoloads.el") (car load-path))))



(autoload 'xref-find-backend "xref" nil nil nil)

(define-obsolete-function-alias 'xref-pop-marker-stack #'xref-go-back "29.1")

(autoload 'xref-go-back "xref" "\
Go back to the previous position in xref history.
To undo, use \\[xref-go-forward]." t nil)

(autoload 'xref-go-forward "xref" "\
Got to the point where a previous \\[xref-go-back] was invoked." t nil)

(autoload 'xref-marker-stack-empty-p "xref" "\
Whether the xref back-history is empty." nil nil)

(autoload 'xref-forward-history-empty-p "xref" "\
Whether the xref forward-history is empty." nil nil)

(autoload 'xref-show-xrefs "xref" "\
Display some Xref values produced by FETCHER using DISPLAY-ACTION.
The meanings of both arguments are the same as documented in
`xref-show-xrefs-function'.

\(fn FETCHER DISPLAY-ACTION)" nil nil)

(autoload 'xref-find-definitions "xref" "\
Find the definition of the identifier at point.
With prefix argument or when there's no identifier at point,
prompt for it.

If sufficient information is available to determine a unique
definition for IDENTIFIER, display it in the selected window.
Otherwise, display the list of the possible definitions in a
buffer where the user can select from the list.

Use \\[xref-go-back] to return back to where you invoked this command.

\(fn IDENTIFIER)" t nil)

(autoload 'xref-find-definitions-other-window "xref" "\
Like `xref-find-definitions' but switch to the other window.

\(fn IDENTIFIER)" t nil)

(autoload 'xref-find-definitions-other-frame "xref" "\
Like `xref-find-definitions' but switch to the other frame.

\(fn IDENTIFIER)" t nil)

(autoload 'xref-find-references "xref" "\
Find references to the identifier at point.
This command might prompt for the identifier as needed, perhaps
offering the symbol at point as the default.
With prefix argument, or if `xref-prompt-for-identifier' is t,
always prompt for the identifier.  If `xref-prompt-for-identifier'
is nil, prompt only if there's no usable symbol at point.

\(fn IDENTIFIER)" t nil)

(autoload 'xref-find-definitions-at-mouse "xref" "\
Find the definition of identifier at or around mouse click.
This command is intended to be bound to a mouse event.

\(fn EVENT)" t nil)

(autoload 'xref-find-references-at-mouse "xref" "\
Find references to the identifier at or around mouse click.
This command is intended to be bound to a mouse event.

\(fn EVENT)" t nil)

(autoload 'xref-find-apropos "xref" "\
Find all meaningful symbols that match PATTERN.
The argument has the same meaning as in `apropos'.
See `tags-apropos-additional-actions' for how to augment the
output of this command when the backend is etags.

\(fn PATTERN)" t nil)
 (define-key esc-map "." #'xref-find-definitions)
 (define-key esc-map "," #'xref-go-back)
 (define-key esc-map [?\C-,] #'xref-go-forward)
 (define-key esc-map "?" #'xref-find-references)
 (define-key esc-map [?\C-.] #'xref-find-apropos)
 (define-key ctl-x-4-map "." #'xref-find-definitions-other-window)
 (define-key ctl-x-5-map "." #'xref-find-definitions-other-frame)

(autoload 'xref-references-in-directory "xref" "\
Find all references to SYMBOL in directory DIR.
Return a list of xref values.

This function uses the Semantic Symbol Reference API, see
`semantic-symref-tool-alist' for details on which tools are used,
and when.

\(fn SYMBOL DIR)" nil nil)

(autoload 'xref-matches-in-directory "xref" "\
Find all matches for REGEXP in directory DIR.
Return a list of xref values.
Only files matching some of FILES and none of IGNORES are searched.
FILES is a string with glob patterns separated by spaces.
IGNORES is a list of glob patterns for files to ignore.

\(fn REGEXP FILES DIR IGNORES)" nil nil)

(autoload 'xref-matches-in-files "xref" "\
Find all matches for REGEXP in FILES.
Return a list of xref values.
FILES must be a list of absolute file names.

See `xref-search-program' and `xref-search-program-alist' for how
to control which program to use when looking for matches.

\(fn REGEXP FILES)" nil nil)

(register-definition-prefixes "xref" '("xref-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/xr-1.23/xr-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/xr-1.23/xr-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/xr-1.23/xr-autoloads.el") (car load-path))))



(autoload 'xr "xr" "\
Convert a regexp string to rx notation; the inverse of `rx'.
Passing the returned value to `rx' (or `rx-to-string') yields a regexp string
equivalent to RE-STRING.  DIALECT controls the choice of keywords,
and is one of:
`verbose'       -- verbose keywords
`brief'         -- short keywords
`terse'         -- very short keywords
`medium' or nil -- a compromise (the default)

\(fn RE-STRING &optional DIALECT)" nil nil)

(autoload 'xr-skip-set "xr" "\
Convert a skip set string argument to rx notation.
SKIP-SET-STRING is interpreted according to the syntax of
`skip-chars-forward' and `skip-chars-backward' and converted to
a character class on `rx' form.
If desired, `rx' can then be used to convert the result to an
ordinary regexp.
See `xr' for a description of the DIALECT argument.

\(fn SKIP-SET-STRING &optional DIALECT)" nil nil)

(autoload 'xr-lint "xr" "\
Detect dubious practices and possible mistakes in RE-STRING.
This includes uses of tolerated but discouraged constructs.
Outright regexp syntax violations are signalled as errors.
If PURPOSE is `file', perform additional checks assuming that RE-STRING
is used to match a file name.
Return a list of (OFFSET . COMMENT) where COMMENT applies at OFFSET
in RE-STRING.

\(fn RE-STRING &optional PURPOSE)" nil nil)

(autoload 'xr-skip-set-lint "xr" "\
Detect dubious practices and possible mistakes in SKIP-SET-STRING.
This includes uses of tolerated but discouraged constructs.
Outright syntax violations are signalled as errors.
The argument is interpreted according to the syntax of
`skip-chars-forward' and `skip-chars-backward'.
Return a list of (OFFSET . COMMENT) where COMMENT applies at OFFSET
in SKIP-SET-STRING.

\(fn SKIP-SET-STRING)" nil nil)

(autoload 'xr-pp "xr" "\
Convert to `rx' notation and output the pretty-printed result.
This function uses `xr' to translate RE-STRING into DIALECT.
It is intended for use from an interactive elisp session.
See `xr' for a description of the DIALECT argument.

\(fn RE-STRING &optional DIALECT)" nil nil)

(autoload 'xr-skip-set-pp "xr" "\
Convert a skip set string to `rx' notation and pretty-print.
This function uses `xr-skip-set' to translate SKIP-SET-STRING
into DIALECT.
It is intended for use from an interactive elisp session.
See `xr' for a description of the DIALECT argument.

\(fn SKIP-SET-STRING &optional DIALECT)" nil nil)

(register-definition-prefixes "xr" '("xr-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/compat-28.1.2.2/compat-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/compat-28.1.2.2/compat-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/compat-28.1.2.2/compat-autoloads.el") (car load-path))))



(register-definition-prefixes "compat-27" '("derived-mode-p"))



(register-definition-prefixes "compat-help" '("compat---describe"))



(register-definition-prefixes "compat-macs" '("compat-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/with-editor-20220810.1159/with-editor-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/with-editor-20220810.1159/with-editor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/with-editor-20220810.1159/with-editor-autoloads.el") (car load-path))))



(autoload 'with-editor-export-editor "with-editor" "\
Teach subsequent commands to use current Emacs instance as editor.

Set and export the environment variable ENVVAR, by default
\"EDITOR\".  The value is automatically generated to teach
commands to use the current Emacs instance as \"the editor\".

This works in `shell-mode', `term-mode', `eshell-mode' and
`vterm'.

\(fn &optional (ENVVAR \"EDITOR\"))" t nil)

(autoload 'with-editor-export-git-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$GIT_EDITOR'." t nil)

(autoload 'with-editor-export-hg-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$HG_EDITOR'." t nil)

(defvar shell-command-with-editor-mode nil "\
Non-nil if Shell-Command-With-Editor mode is enabled.
See the `shell-command-with-editor-mode' command
for a description of this minor mode.")

(custom-autoload 'shell-command-with-editor-mode "with-editor" nil)

(autoload 'shell-command-with-editor-mode "with-editor" "\
Teach `shell-command' to use current Emacs instance as editor.

This is a minor mode.  If called interactively, toggle the
`Shell-Command-With-Editor mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='shell-command-with-editor-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Teach `shell-command', and all commands that ultimately call that
command, to use the current Emacs instance as editor by executing
\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".

CLIENT is automatically generated; EDITOR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming no other variable overrides the effect of \"$EDITOR\".
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Alternatively you can use the `with-editor-async-shell-command',
which also allows the use of another variable instead of
\"EDITOR\".

\(fn &optional ARG)" t nil)

(autoload 'with-editor-async-shell-command "with-editor" "\
Like `async-shell-command' but with `$EDITOR' set.

Execute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;
display output, if any.  With a prefix argument prompt for an
environment variable, otherwise the default \"EDITOR\" variable
is used.  With a negative prefix argument additionally insert
the COMMAND's output at point.

CLIENT is automatically generated; ENVVAR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming it respects ENVVAR as an \"EDITOR\"-like variable.
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Also see `async-shell-command' and `shell-command'.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(autoload 'with-editor-shell-command "with-editor" "\
Like `shell-command' or `with-editor-async-shell-command'.
If COMMAND ends with \"&\" behave like the latter,
else like the former.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(register-definition-prefixes "with-editor" '("server-" "shell-command--shell-command-with-editor-mode" "start-file-process--with-editor-process-filter" "with-editor"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/which-key-20220811.1616/which-key-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/which-key-20220811.1616/which-key-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/which-key-20220811.1616/which-key-autoloads.el") (car load-path))))



(defvar which-key-mode nil "\
Non-nil if Which-Key mode is enabled.
See the `which-key-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `which-key-mode'.")

(custom-autoload 'which-key-mode "which-key" nil)

(autoload 'which-key-mode "which-key" "\
Toggle which-key-mode.

This is a minor mode.  If called interactively, toggle the
`Which-Key mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='which-key-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(autoload 'which-key-setup-side-window-right "which-key" "\
Apply suggested settings for side-window that opens on right." t nil)

(autoload 'which-key-setup-side-window-right-bottom "which-key" "\
Apply suggested settings for side-window that opens on right
if there is space and the bottom otherwise." t nil)

(autoload 'which-key-setup-side-window-bottom "which-key" "\
Apply suggested settings for side-window that opens on bottom." t nil)

(autoload 'which-key-setup-minibuffer "which-key" "\
Apply suggested settings for minibuffer.
Do not use this setup if you use the paging commands. Instead use
`which-key-setup-side-window-bottom', which is nearly identical
but more functional." t nil)

(autoload 'which-key-add-keymap-based-replacements "which-key" "\
Replace the description of KEY using REPLACEMENT in KEYMAP.
KEY should take a format suitable for use in `kbd'. REPLACEMENT
should be a cons cell of the form (STRING . COMMAND) for each
REPLACEMENT, where STRING is the replacement string and COMMAND
is a symbol corresponding to the intended command to be
replaced. COMMAND can be nil if the binding corresponds to a key
prefix. An example is

\(which-key-add-keymap-based-replacements global-map
  \"C-x w\" \\='(\"Save as\" . write-file)).

For backwards compatibility, REPLACEMENT can also be a string,
but the above format is preferred, and the option to use a string
for REPLACEMENT will eventually be removed.

\(fn KEYMAP KEY REPLACEMENT &rest MORE)" nil nil)

(autoload 'which-key-add-key-based-replacements "which-key" "\
Replace the description of KEY-SEQUENCE with REPLACEMENT.
KEY-SEQUENCE is a string suitable for use in `kbd'. REPLACEMENT
may either be a string, as in

\(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")

a cons of two strings as in

\(which-key-add-key-based-replacements \"C-x 8\"
                                        \\='(\"unicode\" . \"Unicode keys\"))

or a function that takes a (KEY . BINDING) cons and returns a
replacement.

In the second case, the second string is used to provide a longer
name for the keys under a prefix.

MORE allows you to specifcy additional KEY REPLACEMENT pairs.  All
replacements are added to `which-key-replacement-alist'.

\(fn KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil)

(autoload 'which-key-add-major-mode-key-based-replacements "which-key" "\
Functions like `which-key-add-key-based-replacements'.
The difference is that MODE specifies the `major-mode' that must
be active for KEY-SEQUENCE and REPLACEMENT (MORE contains
addition KEY-SEQUENCE REPLACEMENT pairs) to apply.

\(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil)

(autoload 'which-key-reload-key-sequence "which-key" "\
Simulate entering the key sequence KEY-SEQ.
KEY-SEQ should be a list of events as produced by
`listify-key-sequence'. If nil, KEY-SEQ defaults to
`which-key--current-key-list'. Any prefix arguments that were
used are reapplied to the new key sequence.

\(fn &optional KEY-SEQ)" nil nil)

(autoload 'which-key-show-standard-help "which-key" "\
Call the command in `which-key--prefix-help-cmd-backup'.
Usually this is `describe-prefix-bindings'.

\(fn &optional _)" t nil)

(autoload 'which-key-show-next-page-no-cycle "which-key" "\
Show next page of keys unless on the last page, in which case
call `which-key-show-standard-help'." t nil)

(autoload 'which-key-show-previous-page-no-cycle "which-key" "\
Show previous page of keys unless on the first page, in which
case do nothing." t nil)

(autoload 'which-key-show-next-page-cycle "which-key" "\
Show the next page of keys, cycling from end to beginning
after last page.

\(fn &optional _)" t nil)

(autoload 'which-key-show-previous-page-cycle "which-key" "\
Show the previous page of keys, cycling from beginning to end
after first page.

\(fn &optional _)" t nil)

(autoload 'which-key-show-top-level "which-key" "\
Show top-level bindings.

\(fn &optional _)" t nil)

(autoload 'which-key-show-major-mode "which-key" "\
Show top-level bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. 

\(fn &optional ALL)" t nil)

(autoload 'which-key-show-full-major-mode "which-key" "\
Show all bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. " t nil)

(autoload 'which-key-dump-bindings "which-key" "\
Dump bindings from PREFIX into buffer named BUFFER-NAME.

PREFIX should be a string suitable for `kbd'.

\(fn PREFIX BUFFER-NAME)" t nil)

(autoload 'which-key-undo-key "which-key" "\
Undo last keypress and force which-key update.

\(fn &optional _)" t nil)

(autoload 'which-key-C-h-dispatch "which-key" "\
Dispatch C-h commands by looking up key in
`which-key-C-h-map'. This command is always accessible (from any
prefix) if `which-key-use-C-h-commands' is non nil." t nil)

(autoload 'which-key-show-keymap "which-key" "\
Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

If NO-PAGING is non-nil, which-key will not intercept subsequent
keypresses for the paging functionality.

\(fn KEYMAP &optional NO-PAGING)" t nil)

(autoload 'which-key-show-full-keymap "which-key" "\
Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

\(fn KEYMAP)" t nil)

(autoload 'which-key-show-minor-mode-keymap "which-key" "\
Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'.

\(fn &optional ALL)" t nil)

(autoload 'which-key-show-full-minor-mode-keymap "which-key" "\
Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'." t nil)

(register-definition-prefixes "which-key" '("evil-state" "which-key-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/wgrep-20210322.2207/wgrep-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/wgrep-20210322.2207/wgrep-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/wgrep-20210322.2207/wgrep-autoloads.el") (car load-path))))



(autoload 'wgrep-setup "wgrep" "\
Setup wgrep preparation." nil nil)

(add-hook 'grep-setup-hook 'wgrep-setup)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "wgrep" '("wgrep-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/web-mode-20220820.1935/web-mode-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/web-mode-20220820.1935/web-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/web-mode-20220820.1935/web-mode-autoloads.el") (car load-path))))



(autoload 'web-mode "web-mode" "\
Major mode for editing web templates.

\(fn)" t nil)

(register-definition-prefixes "web-mode" '("web-mode-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/web-beautify-20161115.2247/web-beautify-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/web-beautify-20161115.2247/web-beautify-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/web-beautify-20161115.2247/web-beautify-autoloads.el") (car load-path))))



(autoload 'web-beautify-html "web-beautify" "\
Format region if active, otherwise the current buffer.

Formatting is done according to the html-beautify command." t nil)

(autoload 'web-beautify-html-buffer "web-beautify" "\
Format the current buffer according to the html-beautify command." nil nil)

(autoload 'web-beautify-css "web-beautify" "\
Format region if active, otherwise the current buffer.

Formatting is done according to the css-beautify command." t nil)

(autoload 'web-beautify-css-buffer "web-beautify" "\
Format the current buffer according to the css-beautify command." nil nil)

(autoload 'web-beautify-js "web-beautify" "\
Format region if active, otherwise the current buffer.

Formatting is done according to the js-beautify command." t nil)

(autoload 'web-beautify-js-buffer "web-beautify" "\
Format the current buffer according to the js-beautify command." nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-beautify" '("web-beautify-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/vertico-0.27/vertico-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/vertico-0.27/vertico-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/vertico-0.27/vertico-autoloads.el") (car load-path))))



(defvar vertico-mode nil "\
Non-nil if Vertico mode is enabled.
See the `vertico-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-mode'.")

(custom-autoload 'vertico-mode "vertico" nil)

(autoload 'vertico-mode "vertico" "\
VERTical Interactive COmpletion.

This is a minor mode.  If called interactively, toggle the
`Vertico mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico" '("vertico-"))



(defvar vertico-buffer-mode nil "\
Non-nil if Vertico-Buffer mode is enabled.
See the `vertico-buffer-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-buffer-mode'.")

(custom-autoload 'vertico-buffer-mode "vertico-buffer" nil)

(autoload 'vertico-buffer-mode "vertico-buffer" "\
Display Vertico in a buffer instead of the minibuffer.

This is a minor mode.  If called interactively, toggle the
`Vertico-Buffer mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-buffer-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-buffer" '("vertico-buffer-"))



(autoload 'vertico-directory-enter "vertico-directory" "\
Enter directory or exit completion with current candidate." t nil)

(autoload 'vertico-directory-up "vertico-directory" "\
Delete N directories before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-delete-char "vertico-directory" "\
Delete N directories or chars before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-delete-word "vertico-directory" "\
Delete N directories or words before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-tidy "vertico-directory" "\
Tidy shadowed file name, see `rfn-eshadow-overlay'." nil nil)

(register-definition-prefixes "vertico-directory" '("vertico-directory--completing-file-p"))



(defvar vertico-flat-mode nil "\
Non-nil if Vertico-Flat mode is enabled.
See the `vertico-flat-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-flat-mode'.")

(custom-autoload 'vertico-flat-mode "vertico-flat" nil)

(autoload 'vertico-flat-mode "vertico-flat" "\
Flat, horizontal display for Vertico.

This is a minor mode.  If called interactively, toggle the
`Vertico-Flat mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-flat-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-flat" '("vertico-flat-"))



(defvar vertico-grid-mode nil "\
Non-nil if Vertico-Grid mode is enabled.
See the `vertico-grid-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-grid-mode'.")

(custom-autoload 'vertico-grid-mode "vertico-grid" nil)

(autoload 'vertico-grid-mode "vertico-grid" "\
Grid display for Vertico.

This is a minor mode.  If called interactively, toggle the
`Vertico-Grid mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-grid-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-grid" '("vertico-grid-"))



(defvar vertico-indexed-mode nil "\
Non-nil if Vertico-Indexed mode is enabled.
See the `vertico-indexed-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-indexed-mode'.")

(custom-autoload 'vertico-indexed-mode "vertico-indexed" nil)

(autoload 'vertico-indexed-mode "vertico-indexed" "\
Prefix candidates with indices.

This is a minor mode.  If called interactively, toggle the
`Vertico-Indexed mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-indexed-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-indexed" '("vertico-indexed-"))



(defvar vertico-mouse-mode nil "\
Non-nil if Vertico-Mouse mode is enabled.
See the `vertico-mouse-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-mouse-mode'.")

(custom-autoload 'vertico-mouse-mode "vertico-mouse" nil)

(autoload 'vertico-mouse-mode "vertico-mouse" "\
Mouse support for Vertico.

This is a minor mode.  If called interactively, toggle the
`Vertico-Mouse mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-mouse-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-mouse" '("vertico-mouse--"))



(defvar vertico-multiform-mode nil "\
Non-nil if Vertico-Multiform mode is enabled.
See the `vertico-multiform-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-multiform-mode'.")

(custom-autoload 'vertico-multiform-mode "vertico-multiform" nil)

(autoload 'vertico-multiform-mode "vertico-multiform" "\
Configure Vertico in various forms per command.

This is a minor mode.  If called interactively, toggle the
`Vertico-Multiform mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-multiform-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-multiform" '("vertico-multiform-"))



(autoload 'vertico-quick-jump "vertico-quick" "\
Jump to candidate using quick keys." t nil)

(autoload 'vertico-quick-exit "vertico-quick" "\
Exit with candidate using quick keys." t nil)

(autoload 'vertico-quick-insert "vertico-quick" "\
Insert candidate using quick keys." t nil)

(register-definition-prefixes "vertico-quick" '("vertico-quick"))



(autoload 'vertico-repeat-save "vertico-repeat" "\
Save Vertico session for `vertico-repeat'.
This function must be registered as `minibuffer-setup-hook'." nil nil)

(autoload 'vertico-repeat-last "vertico-repeat" "\
Repeat last Vertico completion SESSION.
If called interactively from an existing Vertico session,
`vertico-repeat-last' will restore the last input and
last selected candidate for the current command.

\(fn &optional SESSION)" t nil)

(autoload 'vertico-repeat-select "vertico-repeat" "\
Select a Vertico session from the session history and repeat it.
If called from an existing Vertico session, you can select among
previous sessions for the current command." t nil)

(autoload 'vertico-repeat "vertico-repeat" "\
Repeat last Vertico session.
If prefix ARG is non-nil, offer completion menu to select from session history.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-repeat" '("vertico-repeat-"))



(defvar vertico-reverse-mode nil "\
Non-nil if Vertico-Reverse mode is enabled.
See the `vertico-reverse-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-reverse-mode'.")

(custom-autoload 'vertico-reverse-mode "vertico-reverse" nil)

(autoload 'vertico-reverse-mode "vertico-reverse" "\
Reverse the Vertico display.

This is a minor mode.  If called interactively, toggle the
`Vertico-Reverse mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-reverse-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-reverse" '("vertico-reverse-"))



(defvar vertico-unobtrusive-mode nil "\
Non-nil if Vertico-Unobtrusive mode is enabled.
See the `vertico-unobtrusive-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-unobtrusive-mode'.")

(custom-autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" nil)

(autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" "\
Unobtrusive display for Vertico.

This is a minor mode.  If called interactively, toggle the
`Vertico-Unobtrusive mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-unobtrusive-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "vertico-unobtrusive" '("vertico-unobtrusive--orig-count"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/bind-key-20220910.2157/bind-key-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/bind-key-20220910.2157/bind-key-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/bind-key-20220910.2157/bind-key-autoloads.el") (car load-path))))



(autoload 'bind-key "bind-key" "\
Bind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).

KEY-NAME may be a vector, in which case it is passed straight to
`define-key'. Or it may be a string to be interpreted as
spelled-out keystrokes, e.g., \"C-c C-z\". See documentation of
`edmacro-mode' for details.

COMMAND must be an interactive function or lambda form.

KEYMAP, if present, should be a keymap variable or symbol.
For example:

  (bind-key \"M-h\" #\\='some-interactive-function my-mode-map)

  (bind-key \"M-h\" #\\='some-interactive-function \\='my-mode-map)

If PREDICATE is non-nil, it is a form evaluated to determine when
a key should be bound. It must return non-nil in such cases.
Emacs can evaluate this form at any time that it does redisplay
or operates on menu data structures, so you should write it so it
can safely be called at any time.

\(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t)

(autoload 'unbind-key "bind-key" "\
Unbind the given KEY-NAME, within the KEYMAP (if specified).
See `bind-key' for more details.

\(fn KEY-NAME &optional KEYMAP)" nil t)

(autoload 'bind-key* "bind-key" "\
Similar to `bind-key', but overrides any mode-specific bindings.

\(fn KEY-NAME COMMAND &optional PREDICATE)" nil t)

(autoload 'bind-keys "bind-key" "\
Bind multiple keys at once.

Accepts keyword arguments:
:map MAP               - a keymap into which the keybindings should be
                         added
:prefix KEY            - prefix key for these bindings
:prefix-map MAP        - name of the prefix map that should be created
                         for these bindings
:prefix-docstring STR  - docstring for the prefix-map variable
:menu-name NAME        - optional menu string for prefix map
:repeat-docstring STR  - docstring for the repeat-map variable
:repeat-map MAP        - name of the repeat map that should be created
                         for these bindings. If specified, the
                         `repeat-map' property of each command bound
                         (within the scope of the `:repeat-map' keyword)
                         is set to this map.
:exit BINDINGS         - Within the scope of `:repeat-map' will bind the
                         key in the repeat map, but will not set the
                         `repeat-map' property of the bound command.
:continue BINDINGS     - Within the scope of `:repeat-map' forces the
                         same behaviour as if no special keyword had
                         been used (that is, the command is bound, and
                         it's `repeat-map' property set)
:filter FORM           - optional form to determine when bindings apply

The rest of the arguments are conses of keybinding string and a
function symbol (unquoted).

\(fn &rest ARGS)" nil t)

(autoload 'bind-keys* "bind-key" "\


\(fn &rest ARGS)" nil t)

(autoload 'describe-personal-keybindings "bind-key" "\
Display all the personal keybindings defined by `bind-key'." t nil)

(register-definition-prefixes "bind-key" '("bind-key" "compare-keybindings" "get-binding-description" "override-global-m" "personal-keybindings"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/use-package-20220910.25/use-package-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/use-package-20220910.25/use-package-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/use-package-20220910.25/use-package-autoloads.el") (car load-path))))



(autoload 'use-package-autoload-keymap "use-package-bind-key" "\
Loads PACKAGE and then binds the key sequence used to invoke
this function to KEYMAP-SYMBOL. It then simulates pressing the
same key sequence a again, so that the next key pressed is routed
to the newly loaded keymap.

This function supports use-package's :bind-keymap keyword. It
works by binding the given key sequence to an invocation of this
function for a particular keymap. The keymap is expected to be
defined by the package. In this way, loading the package is
deferred until the prefix key sequence is pressed.

\(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)" nil nil)

(autoload 'use-package-normalize-binder "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(defalias 'use-package-normalize/:bind 'use-package-normalize-binder)

(defalias 'use-package-normalize/:bind* 'use-package-normalize-binder)

(defalias 'use-package-autoloads/:bind 'use-package-autoloads-mode)

(defalias 'use-package-autoloads/:bind* 'use-package-autoloads-mode)

(autoload 'use-package-handler/:bind "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)" nil nil)

(defalias 'use-package-normalize/:bind-keymap 'use-package-normalize-binder)

(defalias 'use-package-normalize/:bind-keymap* 'use-package-normalize-binder)

(autoload 'use-package-handler/:bind-keymap "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)" nil nil)

(autoload 'use-package-handler/:bind-keymap* "use-package-bind-key" "\


\(fn NAME KEYWORD ARG REST STATE)" nil nil)

(register-definition-prefixes "use-package-bind-key" '("use-package-handler/:bind*"))



(autoload 'use-package "use-package-core" "\
Declare an Emacs package by specifying a group of configuration options.

For full documentation, please see the README file that came with
this file.  Usage:

  (use-package package-name
     [:keyword [option]]...)

:init            Code to run before PACKAGE-NAME has been loaded.
:config          Code to run after PACKAGE-NAME has been loaded.  Note that
                 if loading is deferred for any reason, this code does not
                 execute until the lazy load has occurred.
:preface         Code to be run before everything except `:disabled'; this
                 can be used to define functions for use in `:if', or that
                 should be seen by the byte-compiler.

:mode            Form to be added to `auto-mode-alist'.
:magic           Form to be added to `magic-mode-alist'.
:magic-fallback  Form to be added to `magic-fallback-mode-alist'.
:interpreter     Form to be added to `interpreter-mode-alist'.

:commands        Define autoloads for commands that will be defined by the
                 package.  This is useful if the package is being lazily
                 loaded, and you wish to conditionally call functions in your
                 `:init' block that are defined in the package.
:hook            Specify hook(s) to attach this package to.

:bind            Bind keys, and define autoloads for the bound commands.
:bind*           Bind keys, and define autoloads for the bound commands,
                 *overriding all minor mode bindings*.
:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the
                 package.  This is like `:bind', but for keymaps.
:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings

:defer           Defer loading of a package -- this is implied when using
                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',
                 `:magic-fallback', or `:interpreter'.  This can be an integer,
                 to force loading after N seconds of idle time, if the package
                 has not already been loaded.
:after           Delay the use-package declaration until after the named modules
                 have loaded. Once load, it will be as though the use-package
                 declaration (without `:after') had been seen at that moment.
:demand          Prevent the automatic deferred loading introduced by constructs
                 such as `:bind' (see `:defer' for the complete list).

:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.
:disabled        The package is ignored completely if this keyword is present.
:defines         Declare certain variables to silence the byte-compiler.
:functions       Declare certain functions to silence the byte-compiler.
:load-path       Add to the `load-path' before attempting to load the package.
:diminish        Support for diminish.el (if installed).
:delight         Support for delight.el (if installed).
:custom          Call `Custom-set' or `set-default' with each variable
                 definition without modifying the Emacs `custom-file'.
                 (compare with `custom-set-variables').
:custom-face     Call `custom-set-faces' with each face definition.
:ensure          Loads the package using package.el if necessary.
:pin             Pin the package to an archive.

\(fn NAME &rest ARGS)" nil t)

(function-put 'use-package 'lisp-indent-function 'defun)

(register-definition-prefixes "use-package-core" '("use-package-"))



(autoload 'use-package-normalize/:delight "use-package-delight" "\
Normalize arguments to delight.

\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:delight "use-package-delight" "\


\(fn NAME KEYWORD ARGS REST STATE)" nil nil)

(register-definition-prefixes "use-package-delight" '("use-package-normalize-delight"))



(autoload 'use-package-normalize/:diminish "use-package-diminish" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:diminish "use-package-diminish" "\


\(fn NAME KEYWORD ARG REST STATE)" nil nil)

(register-definition-prefixes "use-package-diminish" '("use-package-normalize-diminish"))



(autoload 'use-package-normalize/:ensure "use-package-ensure" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:ensure "use-package-ensure" "\


\(fn NAME KEYWORD ENSURE REST STATE)" nil nil)

(register-definition-prefixes "use-package-ensure" '("use-package-"))



(autoload 'use-package-jump-to-package-form "use-package-jump" "\
Attempt to find and jump to the `use-package' form that loaded
PACKAGE. This will only find the form if that form actually
required PACKAGE. If PACKAGE was previously required then this
function will jump to the file that originally required PACKAGE
instead.

\(fn PACKAGE)" t nil)

(register-definition-prefixes "use-package-jump" '("use-package-find-require"))



(autoload 'use-package-lint "use-package-lint" "\
Check for errors in use-package declarations.
For example, if the module's `:if' condition is met, but even
with the specified `:load-path' the module cannot be found." t nil)

(register-definition-prefixes "use-package-lint" '("use-package-lint-declaration"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/transient-20220918.2101/transient-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/transient-20220918.2101/transient-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/transient-20220918.2101/transient-autoloads.el") (car load-path))))



(autoload 'transient-insert-suffix "transient" "\
Insert a SUFFIX into PREFIX before LOC.
PREFIX is a prefix command, a symbol.
SUFFIX is a suffix command or a group specification (of
  the same forms as expected by `transient-define-prefix').
LOC is a command, a key vector, a key description (a string
  as returned by `key-description'), or a coordination list
  (whose last element may also be a command or key).
Remove a conflicting binding unless optional KEEP-OTHER is
  non-nil.
See info node `(transient)Modifying Existing Transients'.

\(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)" nil nil)

(function-put 'transient-insert-suffix 'lisp-indent-function 'defun)

(autoload 'transient-append-suffix "transient" "\
Insert a SUFFIX into PREFIX after LOC.
PREFIX is a prefix command, a symbol.
SUFFIX is a suffix command or a group specification (of
  the same forms as expected by `transient-define-prefix').
LOC is a command, a key vector, a key description (a string
  as returned by `key-description'), or a coordination list
  (whose last element may also be a command or key).
Remove a conflicting binding unless optional KEEP-OTHER is
  non-nil.
See info node `(transient)Modifying Existing Transients'.

\(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)" nil nil)

(function-put 'transient-append-suffix 'lisp-indent-function 'defun)

(autoload 'transient-replace-suffix "transient" "\
Replace the suffix at LOC in PREFIX with SUFFIX.
PREFIX is a prefix command, a symbol.
SUFFIX is a suffix command or a group specification (of
  the same forms as expected by `transient-define-prefix').
LOC is a command, a key vector, a key description (a string
  as returned by `key-description'), or a coordination list
  (whose last element may also be a command or key).
See info node `(transient)Modifying Existing Transients'.

\(fn PREFIX LOC SUFFIX)" nil nil)

(function-put 'transient-replace-suffix 'lisp-indent-function 'defun)

(autoload 'transient-remove-suffix "transient" "\
Remove the suffix or group at LOC in PREFIX.
PREFIX is a prefix command, a symbol.
LOC is a command, a key vector, a key description (a string
  as returned by `key-description'), or a coordination list
  (whose last element may also be a command or key).
See info node `(transient)Modifying Existing Transients'.

\(fn PREFIX LOC)" nil nil)

(function-put 'transient-remove-suffix 'lisp-indent-function 'defun)

(register-definition-prefixes "transient" '("transient"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/tango-plus-theme-20220525.1311/tango-plus-theme-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/tango-plus-theme-20220525.1311/tango-plus-theme-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/tango-plus-theme-20220525.1311/tango-plus-theme-autoloads.el") (car load-path))))



(when (and (boundp 'custom-theme-load-path) load-file-name) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(register-definition-prefixes "tango-plus-theme" '("tango-plus"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/sr-speedbar-20161025.831/sr-speedbar-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/sr-speedbar-20161025.831/sr-speedbar-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/sr-speedbar-20161025.831/sr-speedbar-autoloads.el") (car load-path))))



(autoload 'sr-speedbar-toggle "sr-speedbar" "\
Toggle sr-speedbar window.
Toggle visibility of sr-speedbar by resizing
the `sr-speedbar-window' to a minimal width
or the last width when visible.
Use this function to create or toggle visibility
of a speedbar-window.  It will be created if necessary.

\(fn)" t nil)

(autoload 'sr-speedbar-open "sr-speedbar" "\
Create `sr-speedbar' window.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sr-speedbar" '("sr-speedbar-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/rg-20220521.1653/rg-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/rg-20220521.1653/rg-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/rg-20220521.1653/rg-autoloads.el") (car load-path))))



(defvar rg-keymap-prefix "\3s" "\
Prefix for global `rg' keymap.")

(custom-autoload 'rg-keymap-prefix "rg" t)

(defvar rg-command-line-flags-function 'identity "\
Function to modify command line flags of a search.
The argument of the function is an optional list of search specific
command line flags and the function shall return a list of command
line flags to use.")

(autoload 'rg-define-toggle "rg" "\
Define a command line flag that can be toggled from the rg result buffer.

This will create a function with prefix 'rg-custom-toggle-flag-'
concatenated with the FLAG name, stripped of any leading dashes.  Flag
must be a form that will be evaluated to a string at macro expansion
time.  For instance, if FLAG is '--invert-match' the function name
will be 'rg-custom-toggle-flag-invert-match.  If the flag contains a
value that will be excluded from the function name.

Optional KEY is a key binding that is added to `rg-mode-map'.  If the
optional DEFAULT parameter is non nil the flag will be enabled by default.

\(fn FLAG &optional KEY DEFAULT)" nil t)

(autoload 'rg-enable-default-bindings "rg" "\
Enable the global `rg' default key bindings under PREFIX key.
If prefix is not supplied `rg-keymap-prefix' is used.

\(fn &optional PREFIX)" t nil)

(autoload 'rg-use-old-defaults "rg" "\
Restore default settings pre version 2.0.0." nil nil)

(autoload 'rg-define-search "rg" "\
Define an rg search functions named NAME.
ARGS is a search specification that defines parameters of a search.
It optionally starts with a string that is used as the docstring for
the defined function.  The rest of ARGS contains key value pairs
according to the specification below.  All keys are optional with
specified default if left out.

:query      Method for retrieving the search string.  Allowed values
            are `point' which means extract thing at point and `ask'
            which means prompt the user for a string.  Any form that
            evaluates to a string is allowed.
            Default is `ask'.
:format     Specifies if :query is interpreted literally (`literal')
            or as a regexp (`regexp').  If it is a form, eg.
            (not `current-prefix-arg'), and is non-nil the :query is
            interpreted literally, otherwise as a regexp.
            Default is `regexp'.
:files      Form that evaluates to a file alias or custom file glob.
            `current' means extract alias from current buffer file name,
            `ask' will prompt the user.
            Default is `ask'.
:dir        Root search directory.  Allowed values are `ask' for user
            prompt, `current' for current dir and `project' for project
            root.  Any form that evaluates to a directory string is
            also allowed.
            Default is `ask'.
:confirm    `never', `always', or `prefix' are allowed values.  Specifies
            if the the final search command line string can be modified
            and confirmed by the user.
            Default is `never'.
:flags      `ask' or a list of command line flags that will be used when
            invoking the search.
:menu       Bind the command into `rg-menu'.  Must be a list with three
            items in it.  The first item is the description of the
            group in witch the new command will appear.  If the group
            does not exist a new will be created.  The second item is
            the key binding for this new command (ether a key vector
            or a key description string) and the third item is the
            description of the command that will appear in the menu.

Example:
\(rg-define-search search-home-dir-in-elisp
  \"Doc string.\"
  :query ask
  :format literal
  :files \"elisp\"
  :dir (getenv \"HOME\"))
  :menu (\"Custom\" \"H\" \"Home dir\")

\(fn NAME &rest ARGS)" nil t)

(function-put 'rg-define-search 'lisp-indent-function 'defun)
 (autoload 'rg-project "rg.el" "" t)
 (autoload 'rg-dwim-project-dir "rg.el" "" t)
 (autoload 'rg-dwim-current-dir "rg.el" "" t)
 (autoload 'rg-dwim-current-file "rg.el" "" t)

(autoload 'rg-dwim "rg" "\
Run ripgrep without user interaction figuring out the intention by magic(!).
The default magic searches for thing at point in files matching
current file under project root directory.

With \\[universal-argument] prefix (CURDIR), search is done in
current dir instead of project root.

With repeated \\[universal-argument] prefix, search is done in
the current dir and using the current variable `buffer-file-name'
as a pattern.  Subdirectories are still searched, so different
files with the same name pattern still will be searched.

\(fn &optional CURDIR)" t nil)
 (autoload 'rg-literal "rg.el" "" t)
 (autoload 'rg "rg.el" "" t)

(register-definition-prefixes "rg" '("kill-rg" "rg-"))



(register-definition-prefixes "rg-header" '("rg-"))



(register-definition-prefixes "rg-history" '("rg-history-"))



(autoload 'rg-list-searches "rg-ibuffer" "\
List all `rg-mode' buffers in `ibuffer'." t nil)

(register-definition-prefixes "rg-ibuffer" '("rg-"))


 (autoload 'rg-isearch-current-file "rg-isearch.el" "" t)
 (autoload 'rg-isearch-current-dir "rg-isearch.el" "" t)
 (autoload 'rg-isearch-project "rg-isearch.el" "" t)
 (autoload 'rg-isearch-menu "rg-isearch.el" "" t)

(register-definition-prefixes "rg-isearch" '("rg-get-isearch-string"))


 (autoload 'rg-menu "rg-menu.el" "" t)

(autoload 'rg-enable-menu "rg-menu" "\
Bind `rg-menu' to PREFIX key.
If prefix is not supplied `rg-keymap-prefix' is used.

\(fn &optional PREFIX)" t nil)

(register-definition-prefixes "rg-menu" '("rg-menu-"))



(register-definition-prefixes "rg-result" '("rg-"))



(autoload 'wgrep-rg-setup "wgrep-rg" "\
Setup wgrep rg support." nil nil)

(add-hook 'rg-mode-hook 'wgrep-rg-setup)

(register-definition-prefixes "wgrep-rg" '("wgrep-rg-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/relint-1.20/relint-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/relint-1.20/relint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/relint-1.20/relint-autoloads.el") (car load-path))))



(autoload 'relint-file "relint" "\
Scan FILE, an elisp file, for regexp-related errors.

\(fn FILE)" t nil)

(autoload 'relint-directory "relint" "\
Scan all *.el files in DIR for regexp-related errors.

\(fn DIR)" t nil)

(autoload 'relint-current-buffer "relint" "\
Scan the current buffer for regexp errors.
The buffer must be in emacs-lisp-mode." t nil)

(autoload 'relint-buffer "relint" "\
Scan BUFFER for regexp errors. Return list of diagnostics.
Each element in the returned list has the form

  (MESSAGE EXPR-POS ERROR-POS STRING STRING-IDX SEVERITY),

where MESSAGE is the message string, EXPR-POS the location of the
flawed expression, ERROR-POS the exact position of the error or
nil if unavailable, STRING is nil or a string to which the
message pertains, STRING-IDX is nil or an index into STRING,
and SEVERITY is `error' or `warning'.
The intent is that ERROR-POS is the position in the buffer that
corresponds to STRING at STRING-IDX, if such a location can be
determined.

\(fn BUFFER)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "relint" '("relint-")))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/reformatter-20220627.825/reformatter-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/reformatter-20220627.825/reformatter-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/reformatter-20220627.825/reformatter-autoloads.el") (car load-path))))



(autoload 'reformatter-define "reformatter" "\
Define a reformatter command with NAME.

When called, the reformatter will use PROGRAM and any ARGS to
reformat the current buffer.  The contents of the buffer will be
passed as standard input to the reformatter, which should output
them to standard output.  A nonzero exit code will be reported as
failure, and the output of the command to standard error will be
displayed to the user.

The macro accepts the following keyword arguments:

PROGRAM (required)

  Provides a form which should evaluate to a string at runtime,
  e.g. a literal string, or the name of a variable which holds
  the program path.

ARGS

  Command-line arguments for the program.  If provided, this is a
  form which evaluates to a list of strings at runtime.  Default
  is the empty list.  This form is evaluated at runtime so that
  you can use buffer-local variables to influence the args passed
  to the reformatter program: the variable `input-file' will be
  lexically bound to the path of a file containing the text to be
  reformatted: see the keyword options INPUT-FILE, STDIN and
  STDOUT for more information.

STDIN

  When non-nil (the default), the program is passed the input
  data on stdin.  Set this to nil when your reformatter can only
  operate on files in place.  In such a case, your ARGS should
  include a reference to the `input-file' variable, which will be
  bound to an input path when evaluated.

STDOUT

  When non-nil (the default), the program is expected to write
  the reformatted text to stdout.  Set this to nil if your
  reformatter can only operate on files in place, in which case
  the contents of the temporary input file will be used as the
  replacement text.

INPUT-FILE

  Sometimes your reformatter program might expect files to be in
  a certain directory or have a certain file extension.  This option
  lets you handle that.

  If provided, it is a form which will be evaluated before each
  run of the formatter, and is expected to return a temporary
  file path suitable for holding the region to be reformatted.
  It must not produce the same path as the current buffer's file
  if that is set: you shouldn't be operating directly on the
  buffer's backing file.  The temporary input file will be
  deleted automatically.  You might find the function
  `reformatter-temp-file-in-current-directory' helpful.

MODE

  Unless nil, also generate a minor mode that will call the
  reformatter command from `before-save-hook' when enabled.
  Default is t.

GROUP

  If provided, this is the custom group used for any generated
  modes or custom variables.  Don't forget to declare this group
  using a `defgroup' form.

LIGHTER

  If provided, this is a mode lighter string which will be used
  for the \"-on-save\" minor mode.  It should have a leading
  space.  The supplied value will be used as the default for a
  generated custom variable which specifies the mode lighter.
  Default is nil, ie. no lighter.

KEYMAP

  If provided, this is the symbol name of the \"-on-save\" mode's
  keymap, which you must declare yourself.  Default is no keymap.

EXIT-CODE-SUCCESS-P

  If provided, this is a function object callable with `funcall'
  which accepts an integer process exit code, and returns non-nil
  if that exit code is considered successful.  This could be a
  lambda, quoted symbol or sharp-quoted symbol.  If not supplied,
  the code is considered successful if it is `zerop'.

\(fn NAME &key PROGRAM ARGS (MODE t) (STDIN t) (STDOUT t) INPUT-FILE LIGHTER KEYMAP GROUP (EXIT-CODE-SUCCESS-P \\='zerop))" nil t)

(function-put 'reformatter-define 'lisp-indent-function 'defun)

(register-definition-prefixes "reformatter" '("reformatter-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/popup-20220927.1610/popup-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/popup-20220927.1610/popup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/popup-20220927.1610/popup-autoloads.el") (car load-path))))



(register-definition-prefixes "popup" '("popup-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/orderless-20220918.48/orderless-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/orderless-20220918.48/orderless-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/orderless-20220918.48/orderless-autoloads.el") (car load-path))))



(autoload 'orderless-filter "orderless" "\
Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.

\(fn STRING TABLE &optional PRED)" nil nil)

(autoload 'orderless-all-completions "orderless" "\
Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.  The
matching portions of each candidate are highlighted.
This function is part of the `orderless' completion style.

\(fn STRING TABLE PRED POINT)" nil nil)

(autoload 'orderless-try-completion "orderless" "\
Complete STRING to unique matching entry in TABLE.
This uses `orderless-all-completions' to find matches for STRING
in TABLE among entries satisfying PRED.  If there is only one
match, it completes to that match.  If there are no matches, it
returns nil.  In any other case it \"completes\" STRING to
itself, without moving POINT.
This function is part of the `orderless' completion style.

\(fn STRING TABLE PRED POINT)" nil nil)

(add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions "Completion of multiple components, in any order."))

(autoload 'orderless-ivy-re-builder "orderless" "\
Convert STR into regexps for use with ivy.
This function is for integration of orderless with ivy, use it as
a value in `ivy-re-builders-alist'.

\(fn STR)" nil nil)

(register-definition-prefixes "orderless" '("orderless-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/multiple-cursors-20220821.932/multiple-cursors-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/multiple-cursors-20220821.932/multiple-cursors-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/multiple-cursors-20220821.932/multiple-cursors-autoloads.el") (car load-path))))



(register-definition-prefixes "mc-cycle-cursors" '("mc/"))



(autoload 'mc/edit-lines "mc-edit-lines" "\
Add one cursor to each line of the active region.
Starts from mark and moves in straight down or up towards the
line point is on.

What is done with lines which are not long enough is governed by
`mc/edit-lines-empty-lines'.  The prefix argument ARG can be used
to override this.  If ARG is a symbol (when called from Lisp),
that symbol is used instead of `mc/edit-lines-empty-lines'.
Otherwise, if ARG negative, short lines will be ignored.  Any
other non-nil value will cause short lines to be padded.

\(fn &optional ARG)" t nil)

(autoload 'mc/edit-ends-of-lines "mc-edit-lines" "\
Add one cursor to the end of each line in the active region." t nil)

(autoload 'mc/edit-beginnings-of-lines "mc-edit-lines" "\
Add one cursor to the beginning of each line in the active region." t nil)

(register-definition-prefixes "mc-edit-lines" '("mc/edit-lines-empty-lines"))



(autoload 'mc-hide-unmatched-lines-mode "mc-hide-unmatched-lines-mode" "\
Minor mode when enabled hides all lines where no cursors (and
also hum/lines-to-expand below and above) To make use of this
mode press \"C-'\" while multiple-cursor-mode is active. You can
still edit lines while you are in mc-hide-unmatched-lines
mode. To leave this mode press <return> or \"C-g\"

This is a minor mode.  If called interactively, toggle the
`Mc-Hide-Unmatched-Lines mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `mc-hide-unmatched-lines-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "mc-hide-unmatched-lines-mode" '("hum/"))



(autoload 'mc/mark-next-like-this "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active add a cursor on the next line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-like-this-word "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active, mark the word at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-word-like-this "mc-mark-more" "\
Find and mark the next word of the buffer matching the currently active region
The matching region must be a whole word to be a match
If no region is active add a cursor on the next line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-symbol-like-this "mc-mark-more" "\
Find and mark the next symbol of the buffer matching the currently active region
The matching region must be a whole symbol to be a match
If no region is active add a cursor on the next line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the
currently active region.

If no region is active ,add a cursor on the previous line.

With negative ARG, delete the last one instead.

With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this-word "mc-mark-more" "\
Find and mark the previous part of the buffer matching the
currently active region.

If no region is active, mark the word at the point and find the
previous match.

With negative ARG, delete the last one instead.

With zero ARG, skip the last one and mark previous.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-word-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the
currently active region.

The matching region must be a whole word to be a match.

If no region is active, add a cursor on the previous line.

With negative ARG, delete the last one instead.

With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-symbol-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching
the currently active region.

The matching region must be a whole symbol to be a match.

If no region is active add a cursor on the previous line.

With negative ARG, delete the last one instead.

With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/mark-previous-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/unmark-next-like-this "mc-mark-more" "\
Deselect next part of the buffer matching the currently active region." t nil)

(autoload 'mc/unmark-previous-like-this "mc-mark-more" "\
Deselect prev part of the buffer matching the currently active region." t nil)

(autoload 'mc/skip-to-next-like-this "mc-mark-more" "\
Skip the current one and select the next part of the buffer
matching the currently active region." t nil)

(autoload 'mc/skip-to-previous-like-this "mc-mark-more" "\
Skip the current one and select the prev part of the buffer
matching the currently active region." t nil)

(autoload 'mc/mark-all-like-this "mc-mark-more" "\
Find and mark all the parts of the buffer matching the currently active region" t nil)

(autoload 'mc/mark-all-words-like-this "mc-mark-more" nil t nil)

(autoload 'mc/mark-all-symbols-like-this "mc-mark-more" nil t nil)

(autoload 'mc/mark-all-in-region "mc-mark-more" "\
Find and mark all the parts in the region matching the given search

\(fn BEG END &optional SEARCH)" t nil)

(autoload 'mc/mark-all-in-region-regexp "mc-mark-more" "\
Find and mark all the parts in the region matching the given regexp.

\(fn BEG END)" t nil)

(autoload 'mc/mark-more-like-this-extended "mc-mark-more" "\
Like mark-more-like-this, but then lets you adjust with arrow keys.
The adjustments work like this:

   <up>    Mark previous like this and set direction to 'up
   <down>  Mark next like this and set direction to 'down

If direction is 'up:

   <left>  Skip past the cursor furthest up
   <right> Remove the cursor furthest up

If direction is 'down:

   <left>  Remove the cursor furthest down
   <right> Skip past the cursor furthest down

The bindings for these commands can be changed.
See `mc/mark-more-like-this-extended-keymap'." t nil)

(autoload 'mc/mark-all-like-this-dwim "mc-mark-more" "\
Tries to guess what you want to mark all of.
Can be pressed multiple times to increase selection.

With prefix, it behaves the same as original `mc/mark-all-like-this'

\(fn ARG)" t nil)

(autoload 'mc/mark-all-dwim "mc-mark-more" "\
Tries even harder to guess what you want to mark all of.

If the region is active and spans multiple lines, it will behave
as if `mc/mark-all-in-region'. With the prefix ARG, it will call
`mc/edit-lines' instead.

If the region is inactive or on a single line, it will behave like
`mc/mark-all-like-this-dwim'.

\(fn ARG)" t nil)

(autoload 'mc/mark-all-like-this-in-defun "mc-mark-more" "\
Mark all like this in defun." t nil)

(autoload 'mc/mark-all-words-like-this-in-defun "mc-mark-more" "\
Mark all words like this in defun." t nil)

(autoload 'mc/mark-all-symbols-like-this-in-defun "mc-mark-more" "\
Mark all symbols like this in defun." t nil)

(autoload 'mc/toggle-cursor-on-click "mc-mark-more" "\
Add a cursor where you click, or remove a fake cursor that is
already there.

\(fn EVENT)" t nil)

(defalias 'mc/add-cursor-on-click 'mc/toggle-cursor-on-click)

(autoload 'mc/mark-sgml-tag-pair "mc-mark-more" "\
Mark the tag we're in and its pair for renaming." t nil)

(register-definition-prefixes "mc-mark-more" '("mc--" "mc/"))



(autoload 'mc/mark-pop "mc-mark-pop" "\
Add a cursor at the current point, pop off mark ring and jump
to the popped mark." t nil)



(autoload 'mc/insert-numbers "mc-separate-operations" "\
Insert increasing numbers for each cursor, starting at
`mc/insert-numbers-default' or ARG.

\(fn ARG)" t nil)

(autoload 'mc/insert-letters "mc-separate-operations" "\
Insert increasing letters for each cursor, starting at 0 or ARG.
     Where letter[0]=a letter[2]=c letter[26]=aa

\(fn ARG)" t nil)

(autoload 'mc/reverse-regions "mc-separate-operations" nil t nil)

(autoload 'mc/sort-regions "mc-separate-operations" nil t nil)

(autoload 'mc/vertical-align "mc-separate-operations" "\
Aligns all cursors vertically with a given CHARACTER to the one with the
highest column number (the rightest).
Might not behave as intended if more than one cursors are on the same line.

\(fn CHARACTER)" t nil)

(autoload 'mc/vertical-align-with-space "mc-separate-operations" "\
Aligns all cursors with whitespace like `mc/vertical-align' does" t nil)

(register-definition-prefixes "mc-separate-operations" '("mc--" "mc/insert-numbers-default"))



(autoload 'multiple-cursors-mode "multiple-cursors-core" "\
Mode while multiple cursors are active.

This is a minor mode.  If called interactively, toggle the
`Multiple-Cursors mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `multiple-cursors-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "multiple-cursors-core" '("activate-cursor-for-undo" "deactivate-cursor-after-undo" "multiple-cursors-mode" "unsupported-cmd"))



(autoload 'set-rectangular-region-anchor "rectangular-region-mode" "\
Anchors the rectangular region at point.

Think of this one as `set-mark' except you're marking a
rectangular region. It is an exceedingly quick way of adding
multiple cursors to multiple lines." t nil)

(autoload 'rectangular-region-mode "rectangular-region-mode" "\
A mode for creating a rectangular region to edit

This is a minor mode.  If called interactively, toggle the
`Rectangular-Region mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `rectangular-region-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "rectangular-region-mode" '("rectangular-region-mode" "rrm/"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/markdown-mode-20220829.225/markdown-mode-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/markdown-mode-20220829.225/markdown-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/markdown-mode-20220829.225/markdown-mode-autoloads.el") (car load-path))))



(autoload 'markdown-mode "markdown-mode" "\
Major mode for editing Markdown files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode" "\
Major mode for editing GitHub Flavored Markdown files.

\(fn)" t nil)

(autoload 'markdown-view-mode "markdown-mode" "\
Major mode for viewing Markdown content.

\(fn)" t nil)

(autoload 'gfm-view-mode "markdown-mode" "\
Major mode for viewing GitHub Flavored Markdown content.

\(fn)" t nil)

(autoload 'markdown-live-preview-mode "markdown-mode" "\
Toggle native previewing on save for a specific markdown file.

This is a minor mode.  If called interactively, toggle the
`Markdown-Live-Preview mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `markdown-live-preview-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "markdown-mode" '("defun-markdown-" "gfm-" "markdown"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/marginalia-20220922.1059/marginalia-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/marginalia-20220922.1059/marginalia-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/marginalia-20220922.1059/marginalia-autoloads.el") (car load-path))))



(defvar marginalia-mode nil "\
Non-nil if Marginalia mode is enabled.
See the `marginalia-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `marginalia-mode'.")

(custom-autoload 'marginalia-mode "marginalia" nil)

(autoload 'marginalia-mode "marginalia" "\
Annotate completion candidates with richer information.

This is a minor mode.  If called interactively, toggle the
`Marginalia mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='marginalia-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(autoload 'marginalia-cycle "marginalia" "\
Cycle between annotators in `marginalia-annotator-registry'." t nil)

(register-definition-prefixes "marginalia" '("marginalia-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lv" '("lv-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el") (car load-path))))



(autoload 'jsons-print-path "json-snatcher" "\
Print the path to the JSON value under point, and save it in the kill ring." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-snatcher" '("jsons-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/json-mode-20211011.630/json-mode-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/json-mode-20211011.630/json-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/json-mode-20211011.630/json-mode-autoloads.el") (car load-path))))



(defconst json-mode-standard-file-ext '(".json" ".jsonld") "\
List of JSON file extensions.")

(defsubst json-mode--update-auto-mode (filenames) "\
Update the `json-mode' entry of `auto-mode-alist'.

FILENAMES should be a list of file as string.
Return the new `auto-mode-alist' entry" (let* ((new-regexp (rx-to-string `(seq (eval (cons 'or (append json-mode-standard-file-ext ',filenames))) eot))) (new-entry (cons new-regexp 'json-mode)) (old-entry (when (boundp 'json-mode--auto-mode-entry) json-mode--auto-mode-entry))) (setq auto-mode-alist (delete old-entry auto-mode-alist)) (add-to-list 'auto-mode-alist new-entry) new-entry))

(defvar json-mode-auto-mode-list '(".babelrc" ".bowerrc" "composer.lock") "\
List of filenames for the JSON entry of `auto-mode-alist'.

Note however that custom `json-mode' entries in `auto-mode-alist'
won’t be affected.")

(custom-autoload 'json-mode-auto-mode-list "json-mode" nil)

(defvar json-mode--auto-mode-entry (json-mode--update-auto-mode json-mode-auto-mode-list) "\
Regexp generated from the `json-mode-auto-mode-list'.")

(autoload 'json-mode "json-mode" "\
Major mode for editing JSON files

\(fn)" t nil)

(autoload 'jsonc-mode "json-mode" "\
Major mode for editing JSON files with comments

\(fn)" t nil)

(add-to-list 'magic-fallback-mode-alist '("^[{[]$" . json-mode))

(autoload 'json-mode-show-path "json-mode" "\
Print the path to the node at point to the minibuffer." t nil)

(autoload 'json-mode-kill-path "json-mode" "\
Save JSON path to object at point to kill ring." t nil)

(autoload 'json-mode-beautify "json-mode" "\
Beautify / pretty-print the active region (or the entire buffer if no active region).

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-mode" '("json")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/iflipb-20220612.858/iflipb-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/iflipb-20220612.858/iflipb-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/iflipb-20220612.858/iflipb-autoloads.el") (car load-path))))



(autoload 'iflipb-next-buffer "iflipb" "\
Flip to the next buffer in the buffer list.

Consecutive invocations switch to less recent buffers in the
buffer list. Buffers matching `iflipb-always-ignore-buffers' are
always ignored. Without a prefix argument, buffers matching
`iflipb-ignore-buffers' are also ignored.

\(fn ARG)" t nil)

(autoload 'iflipb-previous-buffer "iflipb" "\
Flip to the previous buffer in the buffer list.

Consecutive invocations switch to more recent buffers in the
buffer list." t nil)

(autoload 'iflipb-kill-buffer "iflipb" "\
Same as `kill-buffer' but keep the iflipb buffer list state." t nil)

(register-definition-prefixes "iflipb" '("iflipb-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/hydra-20220910.1206/hydra-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/hydra-20220910.1206/hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/hydra-20220910.1206/hydra-autoloads.el") (car load-path))))



(autoload 'defhydra "hydra" "\
Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit, :bind, and :column.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

:column is a string that sets the column for all subsequent heads.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

\(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t)

(function-put 'defhydra 'lisp-indent-function 'defun)

(function-put 'defhydra 'doc-string-elt '3)

(register-definition-prefixes "hydra" '("defhydra" "hydra-"))



(register-definition-prefixes "hydra-examples" '("hydra-" "org-agenda-cts" "whitespace-mode"))



(register-definition-prefixes "hydra-ox" '("hydra-ox"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/highlight-indent-guides-20200820.2328/highlight-indent-guides-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/highlight-indent-guides-20200820.2328/highlight-indent-guides-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/highlight-indent-guides-20200820.2328/highlight-indent-guides-autoloads.el") (car load-path))))



(autoload 'highlight-indent-guides-auto-set-faces "highlight-indent-guides" "\
Automatically calculate indent guide faces.
If this feature is enabled, calculate reasonable values for the indent guide
colors based on the current theme's colorscheme, and set them appropriately.
This runs whenever a theme is loaded, but it can also be run interactively." t nil)

(autoload 'highlight-indent-guides-mode "highlight-indent-guides" "\
Display indent guides in a buffer.

If called interactively, enable Highlight-Indent-Guides mode if
ARG is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-indent-guides" '("highlight-indent-guides-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/graphviz-dot-mode-20220309.1336/graphviz-dot-mode-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/graphviz-dot-mode-20220309.1336/graphviz-dot-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/graphviz-dot-mode-20220309.1336/graphviz-dot-mode-autoloads.el") (car load-path))))



(autoload 'company-graphviz-dot-backend "company-graphviz-dot" "\
Company backend for `graphviz-dot-mode'.
In the signature, COMMAND, ARG and IGNORED are mandated by `company-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-graphviz-dot" '("company-g")))



(autoload 'graphviz-dot-mode "graphviz-dot-mode" "\
Major mode for the dot language. \\<graphviz-dot-mode-map>
TAB indents for graph lines.

\\[graphviz-dot-indent-graph]	- Indentation function.
\\[graphviz-dot-preview]	- Previews graph in a buffer.
\\[graphviz-dot-view]	- Views graph in an external viewer.
\\[graphviz-dot-indent-line]	- Indents current line of code.

Variables specific to this mode:

  `graphviz-dot-dot-program'                   (default `dot')
       Program used to compile the graphs.
  `graphviz-dot-preview-extension'             (default `png')
       File type to use for output.
  `graphviz-dot-view-command'                  (default `dotty %s')
       Command to run when `graphviz-dot-view' is executed.
  `graphviz-dot-view-edit-command'             (default nil)
       If the user should be asked to edit the view command.
  `graphviz-dot-save-before-view'              (default t)
       Automatically save current buffer berore `graphviz-dot-view'.

\(fn)" t nil)

(autoload 'graphviz-dot-preview "graphviz-dot-mode" "\
Compile the graph and preview it in an other buffer." t nil)

(autoload 'graphviz-turn-on-live-preview "graphviz-dot-mode" "\
Turn on live preview.
This will update the preview on every save." t nil)

(autoload 'graphviz-turn-off-live-preview "graphviz-dot-mode" "\
Turn off live preview.
Saving the file will no longer also update the preview." t nil)

(add-to-list 'auto-mode-alist '("\\.dot\\'" . graphviz-dot-mode))

(add-to-list 'auto-mode-alist '("\\.gv\\'" . graphviz-dot-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "graphviz-dot-mode" '("dot-menu" "graphviz-")))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/goto-last-change-20150109.1823/goto-last-change-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/goto-last-change-20150109.1823/goto-last-change-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/goto-last-change-20150109.1823/goto-last-change-autoloads.el") (car load-path))))



(autoload 'goto-last-change "goto-last-change" "\
Set point to the position of the last change.
Consecutive calls set point to the position of the previous change.
With a prefix arg (optional arg MARK-POINT non-nil), set mark so \\[exchange-point-and-mark]
will return point to the current position.

\(fn &optional MARK-POINT MINIMAL-LINE-DISTANCE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "goto-last-change" '("goto-last-change-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/git-timemachine-20220920.828/git-timemachine-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/git-timemachine-20220920.828/git-timemachine-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/git-timemachine-20220920.828/git-timemachine-autoloads.el") (car load-path))))



(autoload 'git-timemachine-toggle "git-timemachine" "\
Toggle git timemachine mode." t nil)

(autoload 'git-timemachine "git-timemachine" "\
Enable git timemachine for file of current buffer." t nil)

(autoload 'git-timemachine-switch-branch "git-timemachine" "\
Enable git timemachine for current buffer, switching to GIT-BRANCH.

\(fn GIT-BRANCH)" t nil)

(register-definition-prefixes "git-timemachine" '("git-timemachine-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/filladapt-2.12.2/filladapt-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/filladapt-2.12.2/filladapt-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/filladapt-2.12.2/filladapt-autoloads.el") (car load-path))))



(autoload 'filladapt-mode "filladapt" "\
Toggle Filladapt minor mode.
With arg, turn Filladapt mode on iff arg is positive.  When
Filladapt mode is enabled, auto-fill-mode and the fill-paragraph
command are both smarter about guessing a proper fill-prefix and
finding paragraph boundaries when bulleted and indented lines and
paragraphs are used.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "filladapt" '("filladapt-" "turn-off-filladapt-mode")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/fill-function-arguments-20210617.1538/fill-function-arguments-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/fill-function-arguments-20210617.1538/fill-function-arguments-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/fill-function-arguments-20210617.1538/fill-function-arguments-autoloads.el") (car load-path))))



(autoload 'fill-function-arguments-to-single-line "fill-function-arguments" "\
Convert current bracketed list to a single line." t nil)

(autoload 'fill-function-arguments-to-multi-line "fill-function-arguments" "\
Convert current bracketed list to one line per argument." t nil)

(autoload 'fill-function-arguments-dwim "fill-function-arguments" "\
Fill the thing at point in a context-sensitive way.

If point is a string or comment and
`fill-function-arguments-fall-through-to-fill-paragraph' is
enabled, then just run `fill-paragragh'.

Otherwise if point is inside a bracketed list (e.g. a function
call, an array declaration, etc.) then if the list is currently
on a single line call `fill-function-arguments-to-multi-line',
otherwise call `fill-function-arguments-to-single-line'." t nil)

(register-definition-prefixes "fill-function-arguments" '("fill-function-arguments-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/fd-dired-20210723.549/fd-dired-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/fd-dired-20210723.549/fd-dired-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/fd-dired-20210723.549/fd-dired-autoloads.el") (car load-path))))



(autoload 'fd-dired "fd-dired" "\
Run `fd' and go into Dired mode on a buffer of the output.
The command run (after changing into DIR) is essentially

    fd . ARGS -ls

except that the car of the variable `fd-dired-ls-option' specifies what to
use in place of \"-ls\" as the final argument.

\(fn DIR ARGS)" t nil)

(autoload 'fd-name-dired "fd-dired" "\
Search DIR recursively for files matching the globbing pattern PATTERN,
and run Dired on those files.
PATTERN is a shell wildcard (not an Emacs regexp) and need not be quoted.
The default command run (after changing into DIR) is

    fd . ARGS \\='PATTERN\\=' | fd-dired-ls-option

\(fn DIR PATTERN)" t nil)

(autoload 'fd-grep-dired "fd-dired" "\
Find files in DIR that contain matches for REGEXP and start Dired on output.
The command run (after changing into DIR) is

  fd . ARGS --exec rg --regexp REGEXP -0 -ls | fd-dired-ls-option

\(fn DIR REGEXP)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fd-dired" '("fd-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/eldoc-1.13.0/eldoc-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/eldoc-1.13.0/eldoc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/eldoc-1.13.0/eldoc-autoloads.el") (car load-path))))



(defvar eldoc-minor-mode-string (purecopy " ElDoc") "\
String to display in mode line when ElDoc Mode is enabled; nil for none.")

(custom-autoload 'eldoc-minor-mode-string "eldoc" t)

(autoload 'eldoc-mode "eldoc" "\
Toggle echo area display of Lisp objects at point (ElDoc mode).

This is a minor mode.  If called interactively, toggle the `Eldoc
mode' mode.  If the prefix argument is positive, enable the mode,
and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `eldoc-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

ElDoc mode is a buffer-local minor mode.  When enabled, the echo
area displays information about a function or variable in the
text where point is.  If point is on a documented variable, it
displays the first line of that variable's doc string.  Otherwise
it displays the argument list of the function called in the
expression point is on.

\(fn &optional ARG)" t nil)

(put 'global-eldoc-mode 'globalized-minor-mode t)

(defcustom global-eldoc-mode t "\
Non-nil if Global Eldoc mode is enabled.
See the `global-eldoc-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-eldoc-mode'." :set #'custom-set-minor-mode :initialize 'custom-initialize-delay :type 'boolean)

(custom-autoload 'global-eldoc-mode "eldoc" nil)

(autoload 'global-eldoc-mode "eldoc" "\
Toggle Eldoc mode in all buffers.
With prefix ARG, enable Global Eldoc mode if ARG is positive; otherwise,
disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Eldoc mode is enabled in all buffers where `turn-on-eldoc-mode' would do it.

See `eldoc-mode' for more information on Eldoc mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-eldoc-mode "eldoc" "\
Turn on `eldoc-mode' if the buffer has ElDoc support enabled.
See `eldoc-documentation-strategy' for more detail." nil nil)

(register-definition-prefixes "eldoc" '("eldoc"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/dash-20220608.1931/dash-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/dash-20220608.1931/dash-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/dash-20220608.1931/dash-autoloads.el") (car load-path))))



(autoload 'dash-fontify-mode "dash" "\
Toggle fontification of Dash special variables.

This is a minor mode.  If called interactively, toggle the
`Dash-Fontify mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `dash-fontify-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

\(fn &optional ARG)" t nil)

(put 'global-dash-fontify-mode 'globalized-minor-mode t)

(defvar global-dash-fontify-mode nil "\
Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.")

(custom-autoload 'global-dash-fontify-mode "dash" nil)

(autoload 'global-dash-fontify-mode "dash" "\
Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Dash-Fontify mode is enabled in all buffers where `dash--turn-on-fontify-mode'
would do it.

See `dash-fontify-mode' for more information on Dash-Fontify mode.

\(fn &optional ARG)" t nil)

(autoload 'dash-register-info-lookup "dash" "\
Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol]." t nil)

(register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-juxt" "-keep" "-l" "-m" "-no" "-o" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-"))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/dired-hacks-utils-20201005.2318/dired-hacks-utils-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/dired-hacks-utils-20201005.2318/dired-hacks-utils-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/dired-hacks-utils-20201005.2318/dired-hacks-utils-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dired-hacks-utils" '("dired-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/dired-subtree-20210105.1127/dired-subtree-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/dired-subtree-20210105.1127/dired-subtree-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/dired-subtree-20210105.1127/dired-subtree-autoloads.el") (car load-path))))



(autoload 'dired-subtree-narrow "dired-subtree" "\
Narrow the buffer to this subtree." t nil)

(autoload 'dired-subtree-up "dired-subtree" "\
Jump up one directory.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-down "dired-subtree" "\
Jump down one directory.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-next-sibling "dired-subtree" "\
Go to the next sibling.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-previous-sibling "dired-subtree" "\
Go to the previous sibling.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-beginning "dired-subtree" "\
Go to the first file in this subtree." t nil)

(autoload 'dired-subtree-end "dired-subtree" "\
Go to the first file in this subtree." t nil)

(autoload 'dired-subtree-mark-subtree "dired-subtree" "\
Mark all files in this subtree.

With prefix argument mark all the files in subdirectories
recursively.

\(fn &optional ALL)" t nil)

(autoload 'dired-subtree-unmark-subtree "dired-subtree" "\
Unmark all files in this subtree.

With prefix argument unmark all the files in subdirectories
recursively.

\(fn &optional ALL)" t nil)

(autoload 'dired-subtree-revert "dired-subtree" "\
Revert the subtree.

This means reinserting the content of this subtree and all its
children." t nil)

(autoload 'dired-subtree-insert "dired-subtree" "\
Insert subtree under this directory." t nil)

(autoload 'dired-subtree-remove "dired-subtree" "\
Remove subtree at point." t nil)

(autoload 'dired-subtree-toggle "dired-subtree" "\
Insert subtree at point or remove it if it was not present." t nil)

(autoload 'dired-subtree-cycle "dired-subtree" "\
Org-mode like cycle visibility:

1) Show subtree
2) Show subtree recursively (if previous command was cycle)
3) Remove subtree

Numeric prefix will set max depth

\(fn &optional MAX-DEPTH)" t nil)

(autoload 'dired-subtree-only-this-file "dired-subtree" "\
Remove all the siblings on the route from this file to the top-most directory.

With ARG non-nil, do not remove expanded directories in parents.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-only-this-directory "dired-subtree" "\
Remove all the siblings on the route from this directory to the top-most directory.

With ARG non-nil, do not remove expanded directories in parents.

\(fn &optional ARG)" t nil)

(autoload 'dired-subtree-apply-filter "dired-subtree" "\
Push a local filter for this subtree.

This depends on `dired-filter' package.

It works exactly the same as global dired filters, only
restricted to a subtree.  The global filter is also applied to
the subtree.  The filter action is read from `dired-filter-map'." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dired-subtree" '("dired-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/diffview-20220322.2334/diffview-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/diffview-20220322.2334/diffview-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/diffview-20220322.2334/diffview-autoloads.el") (car load-path))))



(autoload 'diffview-current "diffview" "\
Show current diff buffer in a side-by-side view." t nil)

(autoload 'diffview-region "diffview" "\
Show current diff region in a side-by-side view." t nil)

(autoload 'diffview-message "diffview" "\
Show `message-mode' buffer in a side-by-side view.

This is useful for reading patches from mailing lists." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "diffview" '("diffview-")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/deft-20210707.1633/deft-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/deft-20210707.1633/deft-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/deft-20210707.1633/deft-autoloads.el") (car load-path))))



(autoload 'deft-find-file "deft" "\
Find FILE interactively using the minibuffer.
FILE must exist and be a relative or absolute path, with extension.
If FILE is not inside `deft-directory', fall back to using `find-file'.

\(fn FILE)" t nil)

(autoload 'deft-new-file "deft" "\
Create a new file quickly.
Use either an automatically generated filename or the filter string if non-nil
and `deft-use-filter-string-for-filename' is set.  If the filter string is
non-nil and title is not from filename, use it as the title." t nil)

(autoload 'deft "deft" "\
Switch to *Deft* buffer and load files." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "deft" '("deft-" "org-deft-store-link")))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/browse-kill-ring-20220410.1509/browse-kill-ring-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/browse-kill-ring-20220410.1509/browse-kill-ring-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/browse-kill-ring-20220410.1509/browse-kill-ring-autoloads.el") (car load-path))))



(autoload 'browse-kill-ring-default-keybindings "browse-kill-ring" "\
Set up M-y (`yank-pop') so that it can invoke `browse-kill-ring'.
Normally, if M-y was not preceeded by C-y, then it has no useful
behavior.  This function sets things up so that M-y will invoke
`browse-kill-ring'." t nil)

(autoload 'browse-kill-ring "browse-kill-ring" "\
Display items in the `kill-ring' in another buffer." t nil)

(register-definition-prefixes "browse-kill-ring" '("browse-kill-ring-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/bm-20210421.1351/bm-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/bm-20210421.1351/bm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/bm-20210421.1351/bm-autoloads.el") (car load-path))))



(autoload 'bm-toggle "bm" "\
Toggle bookmark at point." t nil)

(autoload 'bm-toggle-mouse "bm" "\
Toggle a bookmark with a mouse click.
EV is the mouse event.

\(fn EV)" t nil)

(autoload 'bm-lifo-previous "bm" "\
Goto previous bookmark in LIFO order . (that is, most
recently set ones come first, oldest ones come last)" t nil)

(autoload 'bm-lifo-next "bm" "\
Goto next bookmark in LIFO order .(that is, most
recently set ones come first, oldest ones come last)" t nil)

(autoload 'bm-next "bm" nil t nil)

(autoload 'bm-common-next "bm" "\
Goto next bookmark." t nil)

(autoload 'bm-next-mouse "bm" "\
Go to the next bookmark with the scroll wheel.
EV is the mouse event.

\(fn EV)" t nil)

(autoload 'bm-previous "bm" nil t nil)

(autoload 'bm-common-previous "bm" "\
Goto previous bookmark." t nil)

(autoload 'bm-previous-mouse "bm" "\
Go to the previous bookmark with the scroll wheel.
EV is the mouse event.

\(fn EV)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bm" '("bm-" "temporary-bookmark-p")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bm-sync" '("bm-bookmark-")))




)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/beacon-20220730.100/beacon-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/beacon-20220730.100/beacon-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/beacon-20220730.100/beacon-autoloads.el") (car load-path))))



(autoload 'beacon-blink "beacon" "\
Blink the beacon at the position of the cursor.
Unlike `beacon-blink-automated', the beacon will blink
unconditionally (even if `beacon-mode' is disabled), and this can
be invoked as a user command or called from Lisp code." t nil)

(defvar beacon-mode nil "\
Non-nil if Beacon mode is enabled.
See the `beacon-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `beacon-mode'.")

(custom-autoload 'beacon-mode "beacon" nil)

(autoload 'beacon-mode "beacon" "\
Toggle Beacon mode on or off.

This is a minor mode.  If called interactively, toggle the
`Beacon mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='beacon-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\\{beacon-mode-map}

\(fn &optional ARG)" t nil)

(register-definition-prefixes "beacon" '("beacon-"))


)
(let ((load-true-file-name "/home/scfrazer/.emacs.d/elpa/avy-20220910.1936/avy-autoloads.el")(load-file-name "/home/scfrazer/.emacs.d/elpa/avy-20220910.1936/avy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/scfrazer/.emacs.d/elpa/avy-20220910.1936/avy-autoloads.el") (car load-path))))



(autoload 'avy-process "avy" "\
Select one of CANDIDATES using `avy-read'.
Use OVERLAY-FN to visualize the decision overlay.
CLEANUP-FN should take no arguments and remove the effects of
multiple OVERLAY-FN invocations.

\(fn CANDIDATES &optional OVERLAY-FN CLEANUP-FN)" nil nil)

(autoload 'avy-goto-char "avy" "\
Jump to the currently visible CHAR.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-char-in-line "avy" "\
Jump to the currently visible CHAR in the current line.

\(fn CHAR)" t nil)

(autoload 'avy-goto-char-2 "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn CHAR1 CHAR2 &optional ARG BEG END)" t nil)

(autoload 'avy-goto-char-2-above "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-goto-char-2-below "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-isearch "avy" "\
Jump to one of the current isearch candidates." t nil)

(autoload 'avy-goto-word-0 "avy" "\
Jump to a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn ARG &optional BEG END)" t nil)

(autoload 'avy-goto-whitespace-end "avy" "\
Jump to the end of a whitespace sequence.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn ARG &optional BEG END)" t nil)

(autoload 'avy-goto-word-1 "avy" "\
Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.
When SYMBOL is non-nil, jump to symbol start instead of word start.

\(fn CHAR &optional ARG BEG END SYMBOL)" t nil)

(autoload 'avy-goto-word-1-above "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-1-below "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1 "avy" "\
Jump to the currently visible CHAR at a symbol start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-above "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-below "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-subword-0 "avy" "\
Jump to a word or subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).

When PREDICATE is non-nil it's a function of zero parameters that
should return true.

BEG and END narrow the scope where candidates are searched.

\(fn &optional ARG PREDICATE BEG END)" t nil)

(autoload 'avy-goto-subword-1 "avy" "\
Jump to the currently visible CHAR at a subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).
The case of CHAR is ignored.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-or-subword-1 "avy" "\
Forward to `avy-goto-subword-1' or `avy-goto-word-1'.
Which one depends on variable `subword-mode'." t nil)

(autoload 'avy-goto-line "avy" "\
Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG.

\(fn &optional ARG)" t nil)

(autoload 'avy-goto-line-above "avy" "\
Goto visible line above the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-line-below "avy" "\
Goto visible line below the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-end-of-line "avy" "\
Call `avy-goto-line' and move to the end of the line.

\(fn &optional ARG)" t nil)

(autoload 'avy-copy-line "avy" "\
Copy a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-move-line "avy" "\
Move a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-copy-region "avy" "\
Select two lines and copy the text between them to point.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-move-region "avy" "\
Select two lines and move the text between them above the current line." t nil)

(autoload 'avy-kill-region "avy" "\
Select two lines and kill the region between them.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-region "avy" "\
Select two lines and save the region between them to the kill ring.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn ARG)" t nil)

(autoload 'avy-kill-whole-line "avy" "\
Select line and kill the whole selected line.

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines
starting from the selected line.  \\[universal-argument] -3

\\[avy-kill-whole-line] kill three lines backward including the
selected line.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-whole-line "avy" "\
Select line and save the whole selected line as if killed, but don’t kill it.

This command is similar to `avy-kill-whole-line', except that it
saves the line(s) as if killed, but does not kill it(them).

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\(fn ARG)" t nil)

(autoload 'avy-setup-default "avy" "\
Setup the default shortcuts." nil nil)

(autoload 'avy-goto-char-timer "avy" "\
Read one or many consecutive chars and jump to the first one.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn &optional ARG)" t nil)

(autoload 'avy-transpose-lines-in-region "avy" "\
Transpose lines in the active region." t nil)

(register-definition-prefixes "avy" '("avy-"))


)
(setq package-activated-list
      (append
       '(yaml-mode xref xr compat with-editor which-key wgrep web-mode web-beautify vertico bind-key use-package transient tango-plus-theme sr-speedbar rg relint reformatter popup orderless multiple-cursors markdown-mode marginalia lv json-snatcher json-mode iflipb hydra highlight-indent-guides graphviz-dot-mode goto-last-change git-timemachine filladapt fill-function-arguments fd-dired eldoc dash dired-hacks-utils dired-subtree diffview deft browse-kill-ring bm beacon avy)
       package-activated-list))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
        (append
         '("/home/scfrazer/.emacs.d/elpa/dash-20220608.1931" "/home/scfrazer/.emacs.d/elpa/orderless-20220918.48" "/home/scfrazer/.emacs.d/elpa/rg-20220521.1653" "/home/scfrazer/.emacs.d/elpa/transient-20220918.2101" "/home/scfrazer/.emacs.d/elpa/use-package-20220910.25" "/home/scfrazer/.emacs.d/elpa/vertico-0.27" "/home/scfrazer/.emacs.d/elpa/with-editor-20220810.1159" "/home/scfrazer/.emacs.d/elpa/compat-28.1.2.2")
         Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-update-autoloads: t
;; End:
